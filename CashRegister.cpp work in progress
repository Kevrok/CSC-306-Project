#include <iostream>
using namespace std;

int main()
{
	CScreen screen;
	Menu menu;
}

class Menu
{
	while (moreCustomers)//loop until command is given to stop
	{	
		char command;
		cout << "Welcome, press N to start a new customer";
		cin >> command;
		if (command == 'N')
		{
			Tape::Tape(int x, int y, int size);
			while (more)
			{
				string input;
				cout << "Enter a UPC to purchase an item, or a different command";
				getline(cin, input);
				if (input == int)
				{
					Inventory::findItem(input);
					Tape::addItem()//need parameters here

				}
				if (input == 'M')
				{
					int amount;
					cout << "Enter the amount of the item you wish to purchase";
					getline(cin, int amount);
					//modify amount of items given to tape once UPC is entered
				}
				if (input == 'V')
				{
					int removeUPC;
					cout << "Enter the UPC of the item you wish to remove";
					getline(cin, removeUPC);
					Tape::voidItem(removeUPC);
				}
				if (input == 'T')
				{
					int total;
					while (Tape::Node != null)
					{
						total = total + Item.price;
					}
					more = false;
				}
				//
			}
		}
		if (command == 'E')
		{
			~CashRegister();
			moreCustomers = false;
		}
	}
}menu;
//****************************************************************
class CashRegister
{
private:
	Inventory inventory; 
	Item item;

public:
	CashRegister(); //constructor
	~CashRegister(); //deconstructor
	string input; //value from prompt
	float total; //total value of bill
	float registertotal; //total in register
	Tape tape; //hold current items in the order

}register1;

//********************************************************************


struct Item
{
    string description;
	float price;
    string UPC;  //can also do char* UPC; 
	int qoh; //quantity on hand
	Item(string UPC, string description, int price, int qoh);
	~Item();
}item;

//************************************************************************
class Tape
{
	class Node // local class - data element for linked list
	{               // Node is used in a doubly linked list (forward & backward)
	public:
		Item * itemPtr; // pointer to an Item
		Node * nextPtr; // pointer to the next Node
		Node * prevPtr; // pointer to previous Node

		Node() // Constructor: create unconnecting node
		{
			itemPtr = NULL; nextPtr = prevPtr = NULL;
		}
	};

	Node * nHead, *nTail, *nPtr; // linked list pointers
	int itemCount;                       // # items in the list
	int posX, posY;         // (x, y) position of upper left corner of the Tape display
	int displaySize;         // number of Items displayed
	CScreen S;

	// ******* Helper methods ********
	Node * find(string upc); // find node nbr in list and return a pointer to it

public:
	Tape(int x, int y, int size); // constructor - create an empty list
	~Tape(); // destroy the list
	bool addItem(Item * item); // add item to the head of the list
	bool addItem(string upc, string description, float price);
	bool voidItem(string upc); // remove item # nbr from the list
	void displayItems(); // display current Item & the previous displaySize-1 items
	// this will give the illusion of sccrolling - call after every addItem()
};
//************************************************************************************************
Tape::Tape(int x, int y, int size)   // constructor - create an empty list
{
	posX = x; posY = y; displaySize = size;
	nHead = nTail = nPtr = NULL;
	itemCount = 0;
}
Tape::~Tape()   // destructor
{ }
//****************************************************************************************************
bool Tape::addItem(string upc, string description, float price) // add item to the tail of the list
{
	bool rtn = true;  //really should predicate return value on the allocation working

	nPtr = new Node();                                      // create a node
	nPtr->itemPtr = new Item(upc, description, price, 1);   // create & link a dynamic Item
	itemCount++;

	// hook node on head of list


	if (!nHead)    // empty list
		nHead = nTail = nPtr;
	else
	{
		nPtr->nextPtr = nHead;
		nHead = nPtr;
	}

	return rtn;
}
//********************************************************************************************************
bool Tape::voidItem(string upc)  // remove item # nbr from the list
{
	bool rtn = true;
	// find item in list
	// remove item
	return rtn;
}
//****************************************************************************************************
void Tape::displayItems()  // display the displaySize newest items   
{
	S.Box(posX, posY, posX + 25, posY + displaySize + 2, OLIVE); // draw display area
	int  count = 0;
	nPtr = nHead;

	while (nPtr && count++ < displaySize)
	{
		S.GotoXY(posX + 1, posY + count);
		cout << nPtr->itemPtr->UPC << " " << nPtr->itemPtr->description << endl;  // use drawString
		nPtr = nPtr->nextPtr;
	}

}
//******************************************************************************************************
Tape::Node * Tape::find(string upc)  // Private method: find node UPC in list and return a pointer to it
{
	nPtr = nHead;
	while (nPtr)                   // look at each Item until found
	{
		if (nPtr->itemPtr->UPC.compare(upc) == 0)   // if strings are equal
			return nPtr;           // found the node, return a pointer to it in list
		else
			nPtr = nPtr->nextPtr;  // move to next Item
	}
	return NULL;                   // not found
}

//****************************************************************************************************


#include <time.h>
#include <stdio.h>
#include <conio.h>
#include <iostream>

#include "Header.h"

CScreen::CScreen(int iSizeX, int iSizeY)  // init a DOS window
{
	COORD consoleSize = { iSizeY, iSizeX };     // size of window to open
	iForColor = WHITE;                        // default white 
	iBakColor = BLACK;                        // default black

	srand((unsigned)time(NULL));             // seed the random # generator

	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	/* Replaced this with above
	CreateFile((LPCWSTR)"CONOUT$", GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ
	| FILE_SHARE_WRITE, 0L,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0L); */

	SetConsoleScreenBufferSize(hConsole, consoleSize);

	GetConsoleScreenBufferInfo(hConsole, &conInfo);
	curInfo.bVisible = bCursor;  // Hide the cursor.
	SetConsoleCursorInfo(hConsole, &curInfo);
}

CScreen::~CScreen()
{  //CloseHandle(hConsole);
}


//*****************************************************************************
void CScreen::ClearScreen()    // erase the screen to background color
{
	SetColor(iForColor, iBakColor);
	system("cls");
}

//*****************************************************************************
void CScreen::DrawString(char *szStr, int iX, int iY, int iBClr, int iFClr)
{                                     // print text at (x,y)
	if (iX != -1 && iY != -1)
		GotoXY(iX, iY);
	if (iBClr == -1 && iFClr == -1)
		printf("%s", szStr);
	else
	{
		int iFgColor = iForColor, iBkColor = iBakColor;
		SetColor(iBClr, iFClr);
		printf("%s", szStr);
		SetColor(iFgColor, iBkColor);
	}

}

void CScreen::DrawString(int iX, int iY, char *szStr, int iBClr, int iFClr)
{
	if (iX != -1 && iY != -1)
		GotoXY(iX, iY);
	if (iBClr == -1 && iFClr == -1)
		printf("%s", szStr);
	else
	{
		int iFgColor = iForColor, iBkColor = iBakColor;
		SetColor(iBClr, iFClr);
		printf("%s", szStr);
		SetColor(iFgColor, iBkColor);
	}
}

//*****************************************************************************
void CScreen::DrawString(double d, int iX, int iY)
{                                     // print text at (x,y)
	if (iX != -1 && iY != -1)
		GotoXY(iX, iY);
	printf("%.2f", d);
}

//*****************************************************************************
void CScreen::SetColor(int fColor, int bColor)  // set fore/bacground colors
{
	iBakColor = bColor; iForColor = fColor;
	SetConsoleTextAttribute(hConsole, (WORD)((iBakColor << 4) | iForColor));
}

void CScreen::GetColor(int &iFColor, int &iBColor) // return settings
{
	iBColor = iBakColor;
	iFColor = iForColor;
}

//*****************************************************************************
void CScreen::SetFgColor(int iFColor)          // set foreground color
{
	iForColor = iFColor;
	SetConsoleTextAttribute(hConsole, (WORD)((iBakColor << 4) | iForColor));
}

//*****************************************************************************
void CScreen::SetBkColor(int iBColor)          // set background color
{
	iBakColor = iBColor;
	SetConsoleTextAttribute(hConsole, (WORD)((iBakColor << 4) | iForColor));
}

//*****************************************************************************
void CScreen::ClearScreenPos(int iXPos, int iYPos)  // clear screen
{
	//SetColor(iForColor, iBakColor);
	DrawString(" ", iXPos, iYPos);
}

//*****************************************************************************
void CScreen::Delay(int ix, int iy, char szPrompt[])
{
	DrawString(szPrompt, ix, iy);  // prompt on status line
	while (_getch() != '\r');      // loop till <CR>
	DrawString(szPrompt, ix, iy, iBakColor, iBakColor);  // erase prompt
}

//*****************************************************************************
void CScreen::GotoXY(int iX, int iY)     // move cursor to (x,y)
{
	cursorPos.X = iX; cursorPos.Y = iY;
	SetConsoleCursorPosition(hConsole, cursorPos);
}

//*****************************************************************************
void CScreen::CursorOn(bool bCursor)     // turn cursor on/off
{
	curInfo.bVisible = bCursor;                   // set the cursor.
	SetConsoleCursorInfo(hConsole, &curInfo);
}

//*****************************************************************************
float CScreen::GetVal(int iX, int iY)
{
	float val;
	if (iX != -1 && iY != -1)
		GotoXY(iX, iY);
	scanf_s("%f", &val);
	return val;
}

//*****************************************************************************
void CScreen::GetStr(int iX, int iY, char szAns[], int iLen, char szFmt[], bool bEcho)
{   // gets a string of iLen chars specified by fmt
	// fmt = @ - alpha, # - numeric, ~ - alpha/numeric, | - any key	
	char cLetter, *pTemp;
	int iCount = 0, iSize = iLen, iFmtSize = strlen(szFmt);
	bool bMem = false;

	if (iFmtSize != iLen)             // build more/less fmt string
	{
		pTemp = new char[iLen + 1];   // make fmt str to take anything
		strncpy(pTemp, szFmt, iLen);// copy original & add extra
		strncat(pTemp, "||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"
			, (iLen - iFmtSize<0) ? 0 : iLen - iFmtSize);
		pTemp[iLen] = 0;              // terminate the fmt string
		szFmt = pTemp;                // use szFmt to traverse
		bMem = true;                  // flag to delete at bottom
	}

	GotoXY(iX, iY);
	for (int iX1 = 0; iX1<iSize; iX1++)printf("_");// space holders for answer
	while (iCount < iSize + 1)                    // get string from KB
	{
		GotoXY(iX + iCount, iY); printf("%c", ' ');// blank out for new char
		GotoXY(iX + iCount, iY);                  // backup
		if (szFmt[iCount] == '#')                // get a #
		{
			while (!InStr((cLetter = _getch()), "0123456789.") && cLetter != '\b'
				&&cLetter != '\r')printf("\7");
			szAns[iCount] = cLetter;
		}
		else if (szFmt[iCount] == '@')          // get a letter
		{
			while (!InStr((cLetter = toupper(_getch())), "ABCDEFGHIJKLMNOPQRSTUVWXYZ ")
				&& cLetter != '\b'&&cLetter != '\r')printf("\7");
		}
		else if (szFmt[iCount] == '~')          // get a letter or #
		{
			while (!InStr((cLetter = toupper(_getch())), "0123456789.ABCDEFGHIJKLMNOPQRSTUVWXYZ ")
				&& cLetter != '\b'&&cLetter != '\r')printf("\7");
		}
		else if (szFmt[iCount] == '|')          // get any char
		{
			cLetter = _getch();
		}
		else if (szFmt[iCount] == 0)            // get a <CR>
		{
			while (((cLetter = toupper(_getch())) != '\r')
				&& cLetter != '\b')printf("\7");
		}
		else                                    // skip fmt letter
		{
			cLetter = szFmt[iCount];
		}

		if (cLetter == '\r')                    // if <CR> done
		{
			break;
		}
		if (cLetter == '\b')                    // if not backspace
		{
			while (iCount >0 && !InStr(szFmt[--iCount], "#@")); // back up
			continue;
		}
		else
		{
			szAns[iCount++] = cLetter;           // put it in string
			if (bEcho)
				printf("%c", cLetter);
			else
				printf("%c", '*');
		}
	}
	szAns[iCount] = 0;                            // terminate string
	if (bMem)
		delete[] pTemp;
	_flushall();
}

//******************************************************************************
bool CScreen::InStr(char s, char t[])
{  // returns true if s is in t
	bool bRtn = false;
	for (int iX = 0; iX<(int)strlen(t); iX++)
	{
		if (t[iX] == s)
		{
			bRtn = true; break;
		}
	}
	return bRtn;
}

// *****************************************************************************
void CScreen::Box(int iULx, int iULy, int iLRx, int iLRy, int iBkColor)
{
	int iTempBk = iBakColor;   // save old color
	SetBkColor(iBkColor);      // change to new draw color
	for (int i = 0; i<iLRy - iULy; i++)
	for (int c = 0; c<iLRx - iULx; c++)
		DrawString(" ", iULx + c, iULy + i);
	SetBkColor(iTempBk);    // restore original Bk color
}
